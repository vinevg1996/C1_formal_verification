(*
fun serv_fin'(concat_for_serv_fin_t, PRF_ms_out):PRF_serv_fin_out.
fun clnt_fin'(concat_for_clnt_fin_t, PRF_ms_out):PRF_clnt_fin_out.
*)
proba P_fin.
proba p_mutual_PRF.
param N, N1, N2, N3, N4, N5.

equiv(cma_gen_serv_fin_first(serv_fin))
  ! i1 <= N
    new k: PRF_ms_out;
    (
      ! i1_1 <= N1
        Omac_serv(log1: hash_serv_output_t) :=
          return(serv_fin(log1, k)) |
      ! i1_2 <= N2
        Ocheck_serv(m_2: hash_serv_output_t, ma: PRF_serv_fin_out) [useful_change]
          := return(serv_check_fin(m_2, k, ma)) |
      ! i1_3 <= N3
        Omac_clnt(x_1: hash_clnt_output_t) := return(clnt_fin(x_1, k)) |
      ! i1_4 <= N4
        Ocheck_clnt(m_2: hash_clnt_output_t, ma: PRF_clnt_fin_out) [useful_change]
          := return(clnt_check_fin(m_2, k, ma)) |
      ! i1_5 <= N5
        OC_gen_key(log: concat_for_common_key_t) :=
          return(PRF_common_key(k, log))
    )
  <=(N * P_fin(time, N1))=> [computational]
  ! i2 <= N
    new k: PRF_ms_out [unchanged];
    (
      ! i2_1 <= N1
        Omac_serv(x_3: hash_serv_output_t) := let x_2: hash_serv_output_t = x_3 in
        (
          let ma2_1: PRF_serv_fin_out = serv_fin'(x_2, k) in return(ma2_1)
        ) |
      ! i2_2 <= N2
        Ocheck_serv(m_3: hash_serv_output_t, ma_2: PRF_serv_fin_out) [useful_change] :=
          let m_1: hash_serv_output_t = m_3 in
          (
            let ma_1: PRF_serv_fin_out = ma_2 in
            find j_1 = j <= N1 suchthat
              defined(x_2[j], ma2_1[j]) &&
              (m_1 = x_2[j]) &&
              (ma_1 = ma2_1[j]) then
                return(true)
            else
              return(false)
          ) |
      ! i2_3 <= N3
        Omac_clnt(x_1: hash_clnt_output_t) := return(clnt_fin(x_1, k)) |
      ! i2_4 <= N4
        Ocheck_clnt(m_2: hash_clnt_output_t, ma: PRF_clnt_fin_out) [useful_change]
          := return(clnt_check_fin(m_2, k, ma)) |
      ! i2_5 <= N5
        OC_gen_key(log: concat_for_common_key_t) :=
          return(PRF_common_key(k, log))
    ).

equiv(cma_gen_clnt_fin_second(clnt_fin))
  ! i1 <= N
    new k: PRF_ms_out;
    (
      ! i1_1 <= N1
        Omac_serv'(log1: hash_serv_output_t) :=
          return(serv_fin'(log1, k)) |
      ! i1_3 <= N3
        Omac_clnt(x_1: hash_clnt_output_t) := return(clnt_fin(x_1, k)) |
      ! i1_4 <= N4
        Ocheck_clnt(m_2: hash_clnt_output_t, ma: PRF_clnt_fin_out) [useful_change]
          := return(clnt_check_fin(m_2, k, ma)) |
      ! i1_5 <= N5
        OC_gen_key(log: concat_for_common_key_t) :=
          return(PRF_common_key(k, log))
    )
  <=(N * P_fin(time, N3))=> [computational]
  ! i2 <= N
    new k: PRF_ms_out [unchanged];
    (
      ! i2_1 <= N1
        Omac_serv'(log1: hash_serv_output_t) :=
          return(serv_fin'(log1, k)) |
      ! i2_3 <= N3
        Omac_clnt(x_3: hash_clnt_output_t) := let x_2: hash_clnt_output_t = x_3 in
        (
          let ma2_1: PRF_clnt_fin_out = clnt_fin'(x_2, k) in return(ma2_1)
        ) |
      ! i2_4 <= N4
        Ocheck_clnt(m_3: hash_clnt_output_t, ma_2: PRF_clnt_fin_out) [useful_change] :=
          let m_1: hash_clnt_output_t = m_3 in
          (
            let ma_1: PRF_clnt_fin_out = ma_2 in
            find j_1 = j <= N3 suchthat
              defined(x_2[j], ma2_1[j]) &&
              (m_1 = x_2[j]) &&
              (ma_1 = ma2_1[j]) then
                return(true)
            else
              return(false)
          ) |
      ! i2_5 <= N5
        OC_gen_key(log: concat_for_common_key_t) :=
          return(PRF_common_key(k, log))
    ).

equiv(PRF_common_key)
!i1 <= N
  new k: PRF_ms_out;
  (
    !i1_1 <= N1
      Omac_serv'(log1: hash_serv_output_t) :=
        return(serv_fin'(log1, k)) |
    !i1_2 <= N2
      Omac_clnt'(log1: hash_clnt_output_t) :=
        return(clnt_fin'(log1, k)) |
    !i1_3 <= N3
      OC_common_key(log: concat_for_common_key_t) :=
        return(PRF_common_key(k, log))
  )
<=(N * p_mutual_PRF(time, N3))=>
!i2 <= N
  new k: PRF_ms_out;
  (
  !i2_1 <= N1
    Omac_serv'(log1: hash_serv_output_t) :=
      return(serv_fin'(log1, k)) |
  !i2_2 <= N2
    Omac_clnt'(log1: hash_clnt_output_t) :=
      return(clnt_fin'(log1, k)) |
  !i2_3 <= N3
    OC_common_key(log2: concat_for_common_key_t) := let
      log2_1:concat_for_common_key_t = log2 in
         find [unique] j_1 = j <= N3 suchthat
           defined(log2_1[j], r_3[j]) &&
           (log2_1 = log2_1[j]) then
             return(r_3[j_1])
         else
           new r_3: four_keys; return(r_3)
  ).
